<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hebrew Moderation System Test</title>
    <style>
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            margin: 20px; 
            direction: rtl;
            text-align: right;
        }
        .test-section { 
            margin: 20px 0; 
            padding: 15px; 
            border: 1px solid #ddd; 
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .test-input { 
            width: 100%; 
            padding: 10px; 
            margin: 10px 0;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-size: 16px;
        }
        .test-button { 
            padding: 10px 20px; 
            background: #007cba; 
            color: white; 
            border: none; 
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        .test-button:hover { 
            background: #005a87; 
        }
        .result { 
            margin: 10px 0; 
            padding: 10px; 
            border-radius: 4px;
            white-space: pre-wrap;
        }
        .success { 
            background-color: #d4edda; 
            color: #155724; 
            border: 1px solid #c3e6cb;
        }
        .warning { 
            background-color: #fff3cd; 
            color: #856404; 
            border: 1px solid #ffeaa7;
        }
        .error { 
            background-color: #f8d7da; 
            color: #721c24; 
            border: 1px solid #f5c6cb;
        }
        .blocked { 
            background-color: #f5c6cb; 
            color: #721c24; 
            border: 2px solid #dc3545;
            font-weight: bold;
        }
        .test-category {
            font-weight: bold;
            color: #333;
            margin-top: 15px;
            padding: 5px 0;
            border-bottom: 2px solid #007cba;
        }
    </style>
</head>
<body>
    <h1>ğŸ›¡ï¸ ×‘×“×™×§×ª ××¢×¨×›×ª ×”××•×“×¨×¦×™×” ×”×¢×‘×¨×™×ª</h1>
    <p>××¢×¨×›×ª ××§×™×¤×” ×œ×‘×“×™×§×ª ××•×“×¨×¦×™×” ×“×•-×œ×©×•× ×™×ª ×¢× ×ª××™×›×” ×‘×¢×‘×¨×™×ª</p>

    <div class="test-section">
        <h2>×‘×“×™×§×” ×™×“× ×™×ª</h2>
        <input type="text" id="manualInput" class="test-input" placeholder="×”×›× ×¡ ×˜×§×¡×˜ ×œ×‘×“×™×§×”...">
        <button onclick="testManualInput()" class="test-button">×‘×“×•×§ ×˜×§×¡×˜</button>
        <button onclick="resetModeration()" class="test-button" style="background: #dc3545;">××™×¤×•×¡ ××¢×¨×›×ª ××•×“×¨×¦×™×”</button>
        <div id="manualResult" class="result"></div>
    </div>

    <div class="test-section">
        <h2>×‘×“×™×§×•×ª ××•×˜×•××˜×™×•×ª</h2>
        <button onclick="runAllTests()" class="test-button">×”×¨×¥ ××ª ×›×œ ×”×‘×“×™×§×•×ª</button>
        <button onclick="testHebrewProfanity()" class="test-button">× ×™×‘×•×œ×™ ×¤×” ×¢×‘×¨×™×™×</button>
        <button onclick="testEnglishProfanity()" class="test-button">× ×™×‘×•×œ×™ ×¤×” ×× ×’×œ×™×™×</button>
        <button onclick="testMixedLanguage()" class="test-button">×©×¤×” ××¢×•×¨×‘×ª</button>
        <button onclick="testCleanContent()" class="test-button">×ª×•×›×Ÿ × ×§×™</button>
        <div id="autoResults" class="result"></div>
    </div>

    <div class="test-section">
        <h2>×‘×“×™×§×•×ª ××¢×¨×›×ª ×”××–×”×¨×•×ª</h2>
        <button onclick="testWarningSystem()" class="test-button">×‘×“×•×§ ××¢×¨×›×ª 3 ×”××–×”×¨×•×ª</button>
        <div id="warningResults" class="result"></div>
    </div>

    <div class="test-section">
        <h2>×‘×“×™×§×•×ª ×“×¤×•×¡×™× ×ª×¨×‘×•×ª×™×™× ×¢×‘×¨×™×™×</h2>
        <button onclick="testHebrewCulturalPatterns()" class="test-button">×‘×“×•×§ ×“×¤×•×¡×™× ×ª×¨×‘×•×ª×™×™×</button>
        <div id="culturalResults" class="result"></div>
    </div>

    <script>
        // Import the moderation system
        let moderator;

        // Initialize moderation system
        function initModerationSystem() {
            // Create a mock of the ToxicContentModerator class for testing
            class UserModerationTracker {
                constructor() {
                    this.warningCount = parseInt(localStorage.getItem('moderation_warnings') || '0');
                    this.isBlocked = localStorage.getItem('moderation_blocked') === 'true';
                }
                
                addWarning() {
                    this.warningCount++;
                    localStorage.setItem('moderation_warnings', this.warningCount.toString());
                    
                    if (this.warningCount >= 3) {
                        this.blockUser();
                    }
                }
                
                blockUser() {
                    this.isBlocked = true;
                    localStorage.setItem('moderation_blocked', 'true');
                }
                
                reset() {
                    this.warningCount = 0;
                    this.isBlocked = false;
                    localStorage.removeItem('moderation_warnings');
                    localStorage.removeItem('moderation_blocked');
                }
            }

            class ToxicContentModerator {
                constructor() {
                    this.toxicWords = {
                        profanity: [
                            'fuck', 'fucking', 'shit', 'damn', 'bitch', 'ass', 'bastard'
                        ],
                        hate_speech: [
                            'nazi', 'terrorist', 'racist', 'fascist'
                        ]
                    };
                    
                    this.hebrewToxicWords = {
                        profanity: [
                            '×–×™×Ÿ', '×–×™×•×Ÿ', '×™×–×“×™×™×Ÿ', '×–×™× ×™', '×–×™×™×›×ª×™', '×–×•× ×”', '×–×•× ×•×ª', '×›×•×¡', '×›×•×¡×™×ª',
                            '×—×¨×', '×—××¨×', '×—×¨×”', '×©×¨××•×˜×”', '×©×¨××•×˜×•×ª', '×‘×Ÿ ×–×•× ×”', '×‘×ª ×–×•× ×”'
                        ],
                        hate_speech: [
                            '× ××¦×™', '× ××¦×™×', '×”×™×˜×œ×¨', '×¤××©×™×¡×˜', '×’×–×¢×Ÿ', '×’×–×¢× ×™', '×’×–×¢× ×•×ª'
                        ]
                    };
                    
                    this.tracker = new UserModerationTracker();
                    this.shoppingWhitelist = [];
                }
                
                containsHebrew(text) {
                    return /[\u0590-\u05FF]/.test(text);
                }
                
                validateHebrewContent(text) {
                    const hasHebrew = this.containsHebrew(text);
                    
                    if (hasHebrew) {
                        const hebrewCulturalPatterns = [
                            /×›×•×¡.*×××/i,
                            /×–×™×™×Ÿ.*××•×ª×š/i,
                            /××–×“×™×™×Ÿ.*×œ×š/i
                        ];
                        
                        for (const pattern of hebrewCulturalPatterns) {
                            if (pattern.test(text)) {
                                return {
                                    isValid: false,
                                    reason: 'hebrew_cultural_profanity',
                                    pattern: pattern.source
                                };
                            }
                        }
                    }
                    
                    return { isValid: true };
                }
                
                detectToxicContent(text) {
                    const normalizedText = text.toLowerCase().trim();
                    const detectedWords = [];
                    let detectedCategory = null;
                    
                    // Check English words
                    for (const [category, words] of Object.entries(this.toxicWords)) {
                        for (const word of words) {
                            const wordRegex = new RegExp(`\\\\b${word.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'i');
                            if (wordRegex.test(normalizedText)) {
                                detectedWords.push(word);
                                if (!detectedCategory) detectedCategory = category;
                            }
                        }
                    }
                    
                    // Check Hebrew words
                    for (const [category, words] of Object.entries(this.hebrewToxicWords)) {
                        for (const word of words) {
                            if (text.includes(word)) {
                                detectedWords.push(word);
                                if (!detectedCategory) detectedCategory = category;
                            }
                        }
                    }
                    
                    if (detectedCategory) {
                        return {
                            category: detectedCategory,
                            detectedWords: detectedWords,
                            isHebrew: this.containsHebrew(text)
                        };
                    }
                    
                    return null;
                }
                
                getWarningMessage(warningCount, detectedWords = []) {
                    const wordList = detectedWords.length > 0 ? 
                        `\\n\\nDetected words: "${detectedWords.join('", "')}"` : '';
                    
                    const hasHebrewWords = detectedWords.some(word => this.containsHebrew(word));
                    
                    let messages;
                    
                    if (hasHebrewWords) {
                        messages = {
                            1: `ğŸš¨ ××–×”×¨×” 1/3: ×–×•×”×ª×” ×©×¤×” ×œ× ×”×•×œ××ª. ×× × ×©××•×¨ ×¢×œ ×¨×©×™××•×ª ×™×“×™×“×•×ª×™×•×ª ×œ××©×¤×—×” ×•×ª×§×Ÿ ××ª ×”×˜×§×¡×˜.${wordList}`,
                            2: `ğŸš¨ ××–×”×¨×” 2/3: ×”×¤×¨×” ×©× ×™×™×” ×–×•×”×ª×”. ×× × ×”×©×ª××© ×‘×©×¤×” ×”×•×œ××ª ×‘×œ×‘×“. ×”×¤×¨×” × ×•×¡×¤×ª ×ª×—×¡×•× ×–×× ×™×ª ××ª ×”×’×™×©×” ×©×œ×š.${wordList}`,
                            3: `ğŸš¨ ××–×”×¨×” ××—×¨×•× ×” 3/3: ×–×” ×”×¡×™×›×•×™ ×”××—×¨×•×Ÿ ×©×œ×š. ×× × ×”×©×ª××© ×‘×©×¤×” ×”×•×œ××ª ×‘×œ×‘×“. ×”×¤×¨×” ×”×‘××” ×ª×—×¡×•× ××ª ×”×’×™×©×” ×©×œ×š ×œ××¤×œ×™×§×¦×™×”.${wordList}`
                        };
                    } else {
                        messages = {
                            1: `ğŸš¨ Warning 1/3: Inappropriate language detected. Please keep your lists family-friendly and revise your text.${wordList}`,
                            2: `ğŸš¨ Warning 2/3: Second violation detected. Please use appropriate language only. One more violation will temporarily block your access.${wordList}`,
                            3: `ğŸš¨ Final Warning 3/3: This is your last chance. Please use appropriate language only. Next violation will block your access to the app.${wordList}`
                        };
                    }
                    
                    if (this.tracker.isBlocked) {
                        if (hasHebrewWords) {
                            return `ğŸ”’ ×”×’×™×©×” ×—×¡×•××” ×–×× ×™×ª. ×× × ×¨×¢× ×Ÿ ××ª ×”×“×£ ×›×“×™ ×œ××¤×¡ ×•×”×©×ª××© ×‘×©×¤×” ×”×•×œ××ª ×‘×œ×‘×“.`;
                        } else {
                            return `ğŸ”’ Access temporarily blocked. Please refresh the page to reset and use appropriate language only.`;
                        }
                    }
                    
                    return messages[warningCount] || messages[3];
                }
                
                validateContent(inputText) {
                    if (this.tracker.isBlocked) {
                        const hasHebrew = this.containsHebrew(inputText);
                        const blockMessage = hasHebrew ? 
                            'ğŸ”’ ×”×’×™×©×” ×—×¡×•××” ×–×× ×™×ª. ×× × ×¨×¢× ×Ÿ ××ª ×”×“×£ ×›×“×™ ×œ××¤×¡ ×•×”×©×ª××© ×‘×©×¤×” ×”×•×œ××ª ×‘×œ×‘×“.' :
                            'ğŸ”’ Access temporarily blocked. Please refresh the page to reset and use appropriate language only.';
                            
                        return {
                            isValid: false,
                            isBlocked: true,
                            message: blockMessage,
                            warningCount: this.tracker.warningCount
                        };
                    }
                    
                    const hebrewValidation = this.validateHebrewContent(inputText);
                    if (!hebrewValidation.isValid) {
                        this.tracker.addWarning();
                        
                        return {
                            isValid: false,
                            isBlocked: this.tracker.isBlocked,
                            warningCount: this.tracker.warningCount,
                            category: 'hebrew_cultural',
                            detectedWords: [],
                            message: this.getWarningMessage(this.tracker.warningCount, [])
                        };
                    }
                    
                    const detectionResult = this.detectToxicContent(inputText);
                    
                    if (detectionResult) {
                        this.tracker.addWarning();
                        
                        return {
                            isValid: false,
                            isBlocked: this.tracker.isBlocked,
                            warningCount: this.tracker.warningCount,
                            category: detectionResult.category,
                            detectedWords: detectionResult.detectedWords,
                            isHebrew: detectionResult.isHebrew || false,
                            message: this.getWarningMessage(this.tracker.warningCount, detectionResult.detectedWords)
                        };
                    }
                    
                    return { isValid: true };
                }
                
                reset() {
                    this.tracker.reset();
                }
            }

            moderator = new ToxicContentModerator();
            console.log('ğŸ›¡ï¸ Hebrew Moderation System initialized');
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initModerationSystem);

        function testManualInput() {
            const input = document.getElementById('manualInput').value;
            const result = moderator.validateContent(input);
            displayResult('manualResult', input, result);
        }

        function resetModeration() {
            moderator.reset();
            displayMessage('manualResult', 'âœ… ××¢×¨×›×ª ×”××•×“×¨×¦×™×” ××•×¤×¡×” ×‘×”×¦×œ×—×”', 'success');
        }

        function displayResult(elementId, input, result) {
            const element = document.getElementById(elementId);
            let className = result.isValid ? 'success' : (result.isBlocked ? 'blocked' : 'warning');
            let status = result.isValid ? 'âœ… ×ª×•×›×Ÿ ×××•×©×¨' : 
                        result.isBlocked ? 'ğŸ”’ ×—×¡×•×' : 
                        `âš ï¸ ××–×”×¨×” ${result.warningCount}/3`;
            
            element.innerHTML = `
                <strong>×§×œ×˜:</strong> ${input}
                <strong>×ª×•×¦××”:</strong> ${status}
                <strong>×”×•×“×¢×”:</strong> ${result.message || '××™×Ÿ ×”×•×“×¢×”'}
                ${result.category ? `<strong>×§×˜×’×•×¨×™×”:</strong> ${result.category}` : ''}
                ${result.detectedWords ? `<strong>××™×œ×™× ×©×–×•×”×•:</strong> ${result.detectedWords.join(', ')}` : ''}
            `;
            element.className = `result ${className}`;
        }

        function displayMessage(elementId, message, className) {
            const element = document.getElementById(elementId);
            element.innerHTML = message;
            element.className = `result ${className}`;
        }

        function runAllTests() {
            const results = [];
            
            // Test clean Hebrew content
            results.push(testText('×—×œ×‘, ×œ×—×, ×ª×¤×•×—×™×', 'âœ… ×ª×•×›×Ÿ ×¢×‘×¨×™ × ×§×™'));
            
            // Test clean English content
            results.push(testText('milk, bread, apples', 'âœ… ×ª×•×›×Ÿ ×× ×’×œ×™ × ×§×™'));
            
            // Test Hebrew profanity
            results.push(testText('×–×™×Ÿ', 'âŒ × ×™×‘×•×œ ×¤×” ×¢×‘×¨×™'));
            
            // Test English profanity
            results.push(testText('fuck', 'âŒ × ×™×‘×•×œ ×¤×” ×× ×’×œ×™'));
            
            // Test mixed content
            results.push(testText('milk ×—×œ×‘ bread ×œ×—×', 'âœ… ×ª×•×›×Ÿ ××¢×•×¨×‘ × ×§×™'));
            
            // Test Hebrew cultural patterns
            results.push(testText('×›×•×¡ ××× ×©×œ×š', 'âŒ ×“×¤×•×¡ ×ª×¨×‘×•×ª×™ ×¢×‘×¨×™'));
            
            displayResults('autoResults', results);
        }

        function testHebrewProfanity() {
            const hebrewTests = [
                '×–×™×Ÿ', '×–×•× ×”', '×›×•×¡', '×—×¨×', '×©×¨××•×˜×”', '×‘×Ÿ ×–×•× ×”'
            ];
            
            const results = hebrewTests.map(word => testText(word, `âŒ ×¢×‘×¨×™×ª: ${word}`));
            displayResults('autoResults', results);
        }

        function testEnglishProfanity() {
            const englishTests = [
                'fuck', 'shit', 'damn', 'bitch', 'bastard'
            ];
            
            const results = englishTests.map(word => testText(word, `âŒ ×× ×’×œ×™×ª: ${word}`));
            displayResults('autoResults', results);
        }

        function testMixedLanguage() {
            const mixedTests = [
                '×—×œ×‘ milk ×œ×—× bread',
                'shopping list ×¨×©×™××ª ×§× ×™×•×ª',
                '×ª×¤×•×—×™× apples ×‘× × ×•×ª bananas'
            ];
            
            const results = mixedTests.map(text => testText(text, `âœ… ××¢×•×¨×‘: ${text}`));
            displayResults('autoResults', results);
        }

        function testCleanContent() {
            const cleanTests = [
                '×—×œ×‘, ×œ×—×, ×ª×¤×•×—×™×',
                'milk, bread, apples',
                '×“×’×™×, ×‘×©×¨, ×™×¨×§×•×ª',
                'fish, meat, vegetables'
            ];
            
            const results = cleanTests.map(text => testText(text, `âœ… × ×§×™: ${text}`));
            displayResults('autoResults', results);
        }

        function testWarningSystem() {
            // Reset first
            moderator.reset();
            
            const results = [];
            
            // Warning 1
            results.push(testText('×–×™×Ÿ', '××–×”×¨×” ×¨××©×•× ×”'));
            
            // Warning 2
            results.push(testText('×—×¨×', '××–×”×¨×” ×©× ×™×™×”'));
            
            // Warning 3 (should block)
            results.push(testText('×›×•×¡', '××–×”×¨×” ×©×œ×™×©×™×ª - ×¦×¨×™×š ×œ×—×¡×•×'));
            
            // Should be blocked now
            results.push(testText('×ª×¤×•×—', '×¦×¨×™×š ×œ×”×™×•×ª ×—×¡×•×'));
            
            displayResults('warningResults', results);
        }

        function testHebrewCulturalPatterns() {
            const culturalTests = [
                '×›×•×¡ ××× ×©×œ×š',
                '×–×™×™×Ÿ ××•×ª×š',
                '××–×“×™×™×Ÿ ×œ×š',
                '×ª×–×“×™×™×Ÿ ×œ×š'
            ];
            
            const results = culturalTests.map(text => testText(text, `âŒ ×ª×¨×‘×•×ª×™: ${text}`));
            displayResults('culturalResults', results);
        }

        function testText(input, description) {
            const result = moderator.validateContent(input);
            return {
                input,
                description,
                result,
                status: result.isValid ? 'âœ…' : (result.isBlocked ? 'ğŸ”’' : 'âš ï¸')
            };
        }

        function displayResults(elementId, results) {
            const element = document.getElementById(elementId);
            const html = results.map(test => `
                <div style="margin: 10px 0; padding: 10px; border-left: 4px solid ${test.result.isValid ? '#28a745' : (test.result.isBlocked ? '#dc3545' : '#ffc107')}; background: ${test.result.isValid ? '#d4edda' : (test.result.isBlocked ? '#f8d7da' : '#fff3cd')};">
                    <strong>${test.status} ${test.description}</strong><br>
                    <em>×§×œ×˜:</em> ${test.input}<br>
                    ${test.result.message ? `<em>×”×•×“×¢×”:</em> ${test.result.message}<br>` : ''}
                    ${test.result.detectedWords && test.result.detectedWords.length ? `<em>××™×œ×™×:</em> ${test.result.detectedWords.join(', ')}<br>` : ''}
                    ${test.result.warningCount ? `<em>××–×”×¨×•×ª:</em> ${test.result.warningCount}/3<br>` : ''}
                </div>
            `).join('');
            
            element.innerHTML = html;
            element.className = 'result';
        }
    </script>
</body>
</html>